1. 内存分配方式
   * **栈**是由编译器自动分配和释放的，主要是函数体的地址，参数和局部变量，操作方式类似于数据结构中的栈，由高地址像低地址生长，也就是数据结构中的压栈
   * **堆**是由程序员手动申请和释放的， 由低地址向高地址进行生长，像malloc和new，程序员没有手动释放的话会造成内存泄露
   * **程序代码区**用于存放程序的二进制代码的空间
   * **文字常量区**像常量字符串等存放在上图中的只读区，程序结束时，由系统释放
2. 内存分配中堆和栈的区别
   1. 申请释放的区别
        * **栈**：栈是编译器自动申请的，例如在主函数里面，要声明一个int变量a，那么编译器就自动开辟一块内存存放变量a。
        * **堆**：堆则不相同，是由程序员手动申请的，只要程序员感觉程序此处需要用到多大的内存空间，那么就使用malloc或者new来申请固定大小的内存使用。栈的空间在程序结束的时候由系统或者编译器自动释放，而堆则在程序结束前由程序员手动使用free或者delete释放，忘记手动释放在程序运行中造成内存泄漏，由系统在程序结束的时候自动回收。
    2. 申请后系统的响应
        * **栈**：只要栈剩余的空间大小比申请的空间小，系统就自动为其分配空间，否则就会报错说明栈空间溢出。 
        * **堆**：首先要知道操作系统中有一个存放空闲存储块的链表，当程序员申请空间的时候，系统就会遍历整个链表，找到第一个比申请空间大的空闲块节点，系统会将该空闲块从空闲链表中删除，分配给程序，同时系统会记录这个空闲块的首地址和申请的大小，当程序员使用delete释放该空间的时候能够找到该存储区。另外，申请的空间不一定与找到的空闲块大小相同，多出来剩余的空闲区会被系统重新添加到空闲链表中。
    3. 申请的限制
        * **栈**：一种向低地址扩展的数据结构，并且是连续的存储空间，所以栈顶和栈的最大容量是固定的，当申请空间大于栈的剩余空间的时候，就会报错说明overflow，所以栈能够申请的空间是比较有限的。 
        * **堆**：一种向高地址扩展的数据结构，并且是不连续的，因为系统采用的是链表的方式存放空闲存储块，当然是不连续的，链表的遍历方向是由低向高的，所以堆能够申请的空间的大小其实等同于整个系统的虚拟内存，只要还有内存空间，那么堆就能够不受限制的申请空间，这种方式比较灵活，申请空间也较大。 
    4. 申请效率的比较 
        * **栈**：栈空间的申请是由系统自动完成的，所以速度快，但是不受程序员控制。
        * **堆**：空间的申请是由malloc或new来完成的，实现起来较慢，能够产生碎片，但是使用起来方便。
    5. 存放内容 
        * **栈**：栈存放的内容，一般来说是函数地址和相关参数。当主函数要调用一个函数的时候，要对当前断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，然后是调用函数的参数，一般情况下是按照从右向左的顺序入栈，之后是调用函数的局部变量，注意静态变量是存放在全局内存区，是不入栈的；出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。 
        * **堆**：一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来完成的。 
