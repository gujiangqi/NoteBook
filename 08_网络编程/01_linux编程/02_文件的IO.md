# 标准C的I/O
## 标准C的I/O
```C++
char *fgets(char *s,int size,FILE *stream);
int printf(const char *format,...);
```

### FILE类型结构体

```C++
typedef struct iobuf{
    int cnt;        /* 剩余的字节数     */
    char *ptr;      /* 下一个字符的位置 */
    char *base;     /* 缓冲区的位置    */
    int flag;       /* 文件访问位置    */
    int fd;         /* 文件描述符      */
}FILE;
```

用户程序调用标准的IO函数，用到了一个`FILE* sp`,该结构体指针指向一个结构体变量（bese指向了缓存地址,ptr指向了某个字符的位置）

stdin、stdout、stderr是三个file类型的指针，称为流指针

### 三种缓存类型
1. 全缓存：
   * 要求填满整个缓冲区后才进行i/o系统调用操作，对于磁盘文件通常使用全缓存访问
2. 行缓存
   * 涉及一个终端时（例如标准输入和标准输出），使用行缓存
   * 行缓存满自动输出
   * 碰到换行符自动输出

sleep函数头文件
```C++
#include <unistd.h>
```
1. 无缓存
   * 标准错误流stderr通常是不带缓存区的，这使得错误信息能够尽快的显示出来
# 文件描述符
1. 对于内核而言，所有打开文件都是由文件描述符引用，文件描述符是一个非负的整数。当打开一个现存文件或者创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或者write

2. 在POSIX应用程序中，整数0，1，2被替换成符号常数STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO 这些常数都是定义在头文件\<unistd.h\>中。

3. 文件描述符的范围是0--OPEN_MAX，早期的UNIX版本采用的上限值是19(允许每个进程打开20个文件)。现在很多系统则将其增加至63，Linux为1024.

在文件指针中是包含着文件描述符
## 标准文件指针
1. 标准文件指针
    * stdin 0
    * stdout 1
    * stderr 2

2. fdopen()
    * FILE *fdopen(in t fd, const char *mode);
    * 文件描述符=>文件指针

3. fileno()
    * int fileno(FILE * obj)



# 文件I/O的系统调用
linux内核提供的函数都是**不带缓存**的函数，他们不是ANSI C的组成部分，但是POSIX的组成部分

应用代码涉及到C库函数，C库函数还是涉及到系统调用

* 标准库函数遵守ISO标准，基于**文件指针**对文件进行操作
* 系统调用linux，兼容POSIX，基于**文件描述符**对文件进行操作
## open()打开文件
```C++
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname,int flags)
int open(const char *pathname,int falgs,mode_t mode)
```
参数
1. pathname:要打开或者创建的文件路径
2. flags:用来说明此函数的多个选择项
   1. O_RDNOLY:只读
   2. O_WRONLY:只写
   3. O_RDWR:  读写
3. mode:新建文件的访问权限，对于open函数而言，仅当创建一个新的文件才使用第三个参数。 
## create()创建文件
```C++
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int create(const char *pathname,mode_t mode)
```
返回：若成功为只写打开的文件描述符，若出错为-1
功能：创建一个新文件
## close()关闭文件
```C++
#include <unistd.h>
int close(int fd);
```
返回：若成功为0，若出错为-1

当一个进程终止时，它所有打开的文件由内核关闭
## read()读取文件
```C++
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```
返回：读到的字节数，若已到文件尾为0，若出错为-1
功能：从打开文件中读数据
1. fd：文件描述符
2. buf：存放读取数据的缓存
3. count：要求读取一次数据的字节数

有多种情况可使实际读到的字节数少于要求读字节数
* 读普通文件时，在读到要求字节数之前已达到了文件尾端
* 当从终端设备读时，通常一次最多读一行
* 当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数
* 某些面向记录的设备，例如磁带，一次最多返回一个记录
* 进程由于信号造成中断

读操作从文件的当前位移量开始，在成功返回之前，该位移量增加实际读到的字节数
## write()写入文件
```C++
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```
1. fd：文件描述符
2. buf：存放读取数据的缓存
3. count：要求读取一次数据的字节数

## lseek()文件定位


# 文件操作的内核数据结构
# 文件的原子操作
# I/O处理模型
# 文件锁机制
# 存储映射