[TOC]
# 程序和进程

* 程序是存放在磁盘中的可执行文件
* 进程
  * 程序的执行实例被称为进程
  * 进程具有独立的权限与职责、如果系统中某个进程崩溃，它不会影响到其余的进程
  * 每个进程运行在各自的虚拟地址空间中，进程之间可以通过由内核控制的机制相互通讯
* 进程ID
  * 每个Linux进程都一定有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数
  
# 内核中的进程结构
==进程表项==
task_struct ==> 结构体 （进程表项或称为进程控制块）
* state：状态
* flags：
* need_resched:
* priority:
* mm（memory management）:进程管理的信息
* tty：
* signal_lock：信号处理的结构体
* file_struct:指向文件描述符表

# C程序启动过程

* 内核启动特殊户例程
* 启动例程
  * 在进程main函数执行之前内核会启动
  * 该例程放置在/lib/libc.so
* 启动例程
  * 搜集命令行的参数传递给main函数中的argc和argv
  * 搜集环境信息构建环境表并传递给main函数
  * 登记进程的终止函数
  
# 进程终止方式

* 正常终止
  * 从main函数返回
  * 调用exit(标准C库函数)
  * 调用_exit或_Exit(系统调用)
* 异常终止
  * 调用abort
  * 接收到一个信号并终止
  * 最后一个线程对取消请求做处理响应
* 进程返回
  * 通常程序运行成功返回0，否则返回非0
  * 在shell中可以查看进程返回值（echo $?）

atexit()函数
```C++
int atexit(void (*function)(void));
```
* 每个启动的进程都默认登记了一个标准的终止函数
* 终止函数在进程终止时释放进程所占用的一些资源
* 登记的多个终止函数执行顺序是以栈的方式执行，先登记的后执行

终止方式：
1. return
    * 刷新了标准I/O缓存
    * 自动调用终止函数
2. exit()
    在调用的时候调用了内部的函数_exit()和_Exit();
    * 刷新了标准I/O缓存
    * 自动调用终止函数(atexit function2,atexit function1, I/O flush)
3. _exit()/_Exit()
    * 不会刷新标准I/O缓存
    * 不会自动调用终止函数

![](../../91_图片库/进程的启动与关闭.jpg)
# 非局部跳转

# 进程资源限制

# 进程创建、执行和终止
![](\91_图片库/创建进程.jpg)
```C++
pid_t fork(void);   // 子进程中位0，父进程中为子进程ID，出错为-1
pid_t vfork(void);  // 子进程中为0，
```
* fork创建的新进程被称为子进程，该函数被调用一次，但是返回两次，两次返回的区别是：**在子进程中的返回值是0，而在父进程中返回值则是新子进程的进程ID**
* 创建子进程，父子进程哪个先运行根据系统调度且复制父进程的内存空间
* vfork创建子进程，但子进程先运行且不复制父进程的内存空间

## 进程的继承
所有进程系统分配的4G虚拟内存地址都是一样的

父进程fork子进程
子进程会继承父进程的一些信息
* 子进程的继承属性：用户信息和权限、目录信息、信号信息、环境、共享存储段、资源限制、堆、栈和数据段、共享代码段
  * 正文段在物理空间是共享的
  * 数据段，堆，栈，都是全部拷贝过去，然后映射到不同的物理内存
* 子进程特有属性
  * 进程ID，锁信息，运行时间，未决信号
* 操作文件时的内核结构变化
  * 子进程**只继承父进程的文件描述表**，不继承但共享文件表项和i-node
  * 父进程创建一个子进程后,文件表项中的引用计数器加1变成2，当父进程作close操作之后，计数器减1，子进程还是可以使用文件表项，只有当计数器为0时才会释放文件表项。

缓存主要是在堆中
# 进程类型

# 进程状态
PS查看进程状态
* -ef 查看所有的进程 ps -ef | more 
```C++
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Oct10 ?        00:52:21 /sbin/init
root         2     0  0 Oct10 ?        00:00:00 [kthreadd]
root         3     2  0 Oct10 ?        00:00:02 [migration/0]
root         4     2  0 Oct10 ?        00:00:57 [ksoftirqd/0]
```
UID:User ID
PID：process ID
PPID：父进程
Stime：Start time

* -aux | more
```C++
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.0  19364  1536 ?        Ss   Oct10  52:21 /sbin/init
root         2  0.0  0.0      0     0 ?        S    Oct10   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    Oct10   0:02 [migration/0
]
root         4  0.0  0.0      0     0 ?        S    Oct10   0:57 [ksoftirqd/0
```
* user: 进程的属主
* PID
* CPU：进程占用CPU百分比
* MEM：占用内存的百分比
* Ni：进程的nice值，数值大，表示较少的占用cpu时间
* VSZ: 进程虚拟大小
* RSS：驻留中页的数量
* TTY：z终端ID
* wchan：正在等待的进程资源
* start：启动进程的时间
* time：进程消耗CPU的时间
* command：命令的名称和参数


进程常见的状态：
* 运行状态
    * 系统当前状态
    * 就绪状态进程
    * PS命令的stat列为R
* 等待状态
    * 等待时间发生
    * 等待系统资源
    * ps 命令的stat列为s（可中断的等待），如果是不可中断的等待是D
* 停止状态
    * ps命令的stat列为值T
* 僵尸状态
    * 进程终止或结束
    * 在进程表项中仍有记录
    * PS 命令的stat列为值Z
# 进程组

# 进程的调度
多用户：多个用户执行同一个进程
多任务：同一个用户可以执行多一个进程

进程会被CPU分配时间片，分时系统，分配的优先级决定分配的先后，所以涉及到内存的**交换**
1. 处理内核中的工作
2. 处理当前进程
3. 选择进程
    * 实时进程
    * 普通进程
4. 进程交换

分配策略
* 策略
    * 轮流策略
    * 先进先出策略
* 优先权
    * Jiffies变量
* 实时优先权
    * 实时进程之间
* 计数器

进程状态变化关系
正在运行态  当时间片到 切换到就绪态  
正在运行态  进程终止，但是在进程表还有信息  就会到将死态
停止态（进程跟踪命令），不能直接到正在运行态，先到就绪态
等待状态又可称为阻塞状态或者挂起
单个cpu只能运行一个进程，只能相互切换的时间过快，宏观上感觉不出来
![](../../91_图片库/进程状态变化关系.jpg)

## 进程标识
实际用户：是指登录linux的时候的用户
有效用户：是指进程的执行用户
```C++
pid_t getpid(void);
uid_t getuid(void);    // 或者当前进程的实际用户ID
uid_t geteuid(void);   // 获取当前进程的有效用户ID
gid_t getgid(void);    // 获得当前进程的用户组ID
pid_t getppid(void);   // 获得当前进程的父进程ID
pid_t getpgrp(void);   // 获得当前进程所在进程组的ID
pid_t getpgid(pid_t pid); //获得进程ID为pid所在进程组的Id
```


#  进程链和进程扇
进程链：子进程fork出孙进程...
进程扇：父进程fork出多个子进程，进程扇