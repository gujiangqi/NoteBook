[TOC]
# 线程的介绍

## 线程的概念
* 进程是资源管理的最小单位，线程是**程序执行的最小单位**
* 每个进程有自己的数据段、代码段和堆栈段。线程通常叫做轻型的进程，它包含**独立的栈和cpu寄存器状态**，线程是线程的一条执行路径，每个线程共享其所附属进程的所有资源，包括打开的文件、内存页面、信号标识及动态分配的内存等
* 因为线程和进程比起来很小，所以相对来说，线程花费更少的CPU资源
* 在操作系统设计上，从进程演化出线程，最主要的目的就是更好地支持多处理器，并且减少进程上下文切换的开销

## 进程和线程的关系
线程是属于进程，线程运行在进程空间内，同一进程所产生的线程共享同一用户内存空间，当进程退出时，该进程所产生的线程都会被强制退出并清除。一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（CPU，内存，文件）。而将线程分配到某个cpu上执行

## 线程的分类
* 线程按照其调度者可分为**用户级线程**和**内核级线程**两种
  * 用户级线程：主要解决的是上下文切换的问题，其调度过程由用户决定
  * 内核级线程：由内核调度机制实现
* 现在大多数操作系统都采用**用户级线程和内核级线程**并存的方法
* 用户级线程要绑定内核级线程运行，一个进程中的内核进程会分配到固定的时间片，用户级线程分配的时间片以内核级线程为准
* 默认情况下用户级线程和内核级线程是**一对一**，也可以多对一，这样实时性就会比较差
* 当cpu分配给线程的时间片用完后但线程没有执行完毕，此时线程会从运行状态返回到就绪状态，将cpu让给其他线程使用

## 线程的标识
* 每个进程内部的不同线程都有自己的唯一标识（ID）
* 线程标识只在它所属的进程环境中有效
* 线程标识是pthread_t数据类型
```C++
int pthread equal(pthread_t,pthread_t)  // 相等返回非0，否则返回0
pthread_t pthread_self(void); // 调用线程的线程ID
```
# 线程的实现

## Linux线程的实现
* 以下线程均为用户级线程，在linux中，一般采用pthread线程库实现线程的访问与控制，由posix提出，具有良好的可已执行
* Linux需要通过g++**链接动态库pthread**

## 线程的创建

### 创建函数
```C++
int pthread_create(pthread_t *restrict tidp,const pthread_attr_t * restrict attr,void*(*start_rtn)(void*),void * restrict arg);
```
成功返回0，否则返回错误编号

* 参数
  * tidp:线程标识符指针
  * attr:线程属性指针
  * start_rtn：线程运行函数的起始地址
  * arg:传递线程运行函数的参数
* 新创建线程从start_rtn函数的地址开始运行
* 不能保证新线程和调用线程的执行顺序

### 案例
```C++
struct RaceArg
{
    char name[20];
    int time;
    int start;
    int end;
};

void *th_fn(void *arg)
{
    RaceArg *r = (RaceArg *)arg;
    int i = r->start;
    for (; i < r->end; i++)
    {
        printf("%s(%lx) running %d\n", r->name, pthread_self(), i);
        usleep(r->time);
    }
    return NULL;
}

int main(int argc, char *argv[])
{
    int err;
    RaceArg r_a = {"rabbit", (int)(drand48() * 100000000), 20, 50};
    RaceArg t_a = {"turtule", (int)(drand48() * 100000000), 10, 60};
    pthread_t rabbit, turtle;
    if ((err = pthread_create(&rabbit, NULL, th_fn, (void *)&r_a)) != 0)
    {
        perror("rabbit pthread_create error");
        exit(1);
    }
    if ((err = pthread_create(&turtle, NULL, th_fn, (void *)&t_a)) != 0)
    {
        perror("turtle pthread_create error");
        exit(1);
    }

    pthread_join(rabbit, NULL);
    pthread_join(turtle, NULL);

    printf("control thread id:%lx \n", pthread_self());
    printf("finished \n");

    system("pause");
    return 0;
}
```

# 线程的终止
* 主动终止
    * 线程的执行函数中调用return语句
    * 调用了pthread_exit()
    ```C++
    int pthread_exit(void * )
    ```
* 被动终止
    * 线程可以被同一进程的其他线程取消，其他线程调用pthread_cancel(pthread_tid)
## 终止函数
* pthread_cancel(pthread_t tid);
* pthread_exit(void *retval)
由于一个进程中的多个进程共享数据段，因此通常在线程退出后，退出线程所占用的资源并不会随线程结束而释放。所有需要pthread_join函数来等待线程结束，类似于wait系统调用
* pthread_join(pthread_t th,void ** thread_return)
	* th:被等待线程的标识符
	* thread_return: 用来存储被等待线程的返回值

# 线程的清理和控制函数

```C++
void pthread_cleanup_push(void(*rtn)(void *),void *arg);
void pathread_cleanup_pop(int execute);
//这两个函数是成对出现的
```
* 参数
  * rtn：清理函数指针
  * arg：调用清理函数传递的参数
  * execute：值1时执行线程清理函数，值0时不执行线程清理函数
* 触发线程调用清理函数的动作
  * 调用pthread_exit
  * 响应取消请求
  * 用非零execute参数调用thread_cleanup_pop时


# 线程的特性

1. 多线程编程尽可能使用局部变量，避免冲突